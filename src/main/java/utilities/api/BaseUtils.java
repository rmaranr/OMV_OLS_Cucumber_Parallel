package utilities.api;import com.aventstack.extentreports.ExtentTest;import com.github.javafaker.Faker;import io.cucumber.java.Scenario;import io.restassured.path.json.JsonPath;import io.restassured.response.Response;import io.restassured.specification.RequestSpecification;import org.json.JSONArray;import org.json.JSONObject;import org.junit.Assert;import org.testng.asserts.SoftAssert;import javax.json.JsonArray;import javax.json.JsonObject;import java.io.File;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.*;import java.util.regex.Matcher;import java.util.regex.Pattern;import java.util.stream.Collectors;import java.util.stream.IntStream;public class BaseUtils {    public static String environment;    public static String clientCountry;    public static String suiteFileName;    public static String customerEndPoint;    public static String authorizationToken;    public static String reportCategoryDescription;    public static String currentUserName;    public static String currentPassword;    public static Response response;    public static Response locationResponse;    public static Response responseForValidateProfile;    public static Response responseForSpecificCardControlProfile;    public static Response responseValidation;    public static JSONObject requestCardDetailsParams = new JSONObject();    public static JsonObject requestBodyParams;    public static JsonArray requestArrayParams;    public JSONObject requestParams = new JSONObject();    public RequestSpecification request;    public JsonPath jsonPathEvaluator;    public static ExtentTest test;    public String fileSeparator = System.getProperty("file.separator");    public String olsUserName, olsPassword;    public String dbName, dbUserName, dbPassword;    public String commonPropertyFilePath = System.getProperty("config.folder.path") + "/common.properties";    public File commonPropertyFile = new File(commonPropertyFilePath);    public String propertyFilePath;    public Properties commonProp = PropUtils.getProps(commonPropertyFile);    public String inputDataFilePath = System.getProperty("config.folder.path") + "/" + PropUtils.getPropValue(PropUtils.getProps(commonPropertyFile), "environment") + ".properties";//    public String inputDataFilePath = "./src/test/config/" + environment + ".properties";    public File inputDataFile = new File(inputDataFilePath);    public Properties inputProp = PropUtils.getProps(inputDataFile);    public String testExecutionCountFilePath = System.getProperty("config.folder.path") + "/testexecutioncount.properties";    public File testExecutionCountFile = new File(testExecutionCountFilePath);    public Properties testExecutionCountProperties = PropUtils.getProps(testExecutionCountFile);    public String testDataFilePath = getTestDataFilePath(environment);    public File testDataFile = new File(testDataFilePath);    public Properties testDataProperties = PropUtils.getProps(testDataFile);    JSONObject builder = new JSONObject();    /*    Method to get test data file path     */    public String getTestDataFilePath(String environment) {        testDataFilePath = System.getProperty("config.folder.path") + "/testdata-" + PropUtils.getPropValue(PropUtils.getProps(commonPropertyFile), "environment") + ".properties";//        if(System.getenv("environment").equals("apacdev1")){//            testDataFilePath = System.getProperty("config.folder.path")+"/testdata-apacdev1.properties";//        }else if(System.getenv("environment").equals("apacdev6")){//            testDataFilePath = System.getProperty("config.folder.path")+"/testdata-apacdev6.properties";//        }//        else if(System.getenv("environment").equals("omvapacdev6")){//            testDataFilePath = System.getProperty("config.folder.path")+"/testdata-omvapacdev6.properties";//        }        return testDataFilePath;    }    /*    Initialize DB Environment     */    public void initializeDBEnvironment() {        inputProp = PropUtils.getProps(new File(System.getProperty("config.folder.path") + "/" + PropUtils.getPropValue(PropUtils.getProps(commonPropertyFile), "environment") + ".properties"));        dbName = PropUtils.getPropValue(inputProp, "sqlODSServerName");        dbUserName = PropUtils.getPropValue(inputProp, "sqlUserId");        dbPassword = PropUtils.getPropValue(inputProp, "sqlPassword");    }    public String getOLSUerName() {        olsUserName = currentUserName;        return olsUserName;    }    public String getOLSPassword() {        olsPassword = currentPassword;        return olsPassword;    }    public void setDBNameUserNamePassword() {    }    public void setEnvironment(String env) {        environment = env;    }    public String getEnv() {//        String environment = "", clientCountry="", suiteFileName="";        commonPropertyFilePath = System.getProperty("config.folder.path") + "/common.properties";        commonPropertyFile = PropUtils.getPropFile(System.getProperty("config.folder.path") + "/", "common.properties");        try {            environment = System.getProperty("environment");            suiteFileName = System.getProperty("suiteFileName");            clientCountry = System.getProperty("clientCountry");            PropUtils.setProps("environment", environment, commonPropertyFilePath);            PropUtils.setProps("suiteFileName", suiteFileName, commonPropertyFilePath);            PropUtils.setProps("clientCountry", clientCountry, commonPropertyFilePath);            propertyFilePath = System.getProperty("config.folder.path") + "/" + environment + ".properties";            //  PropUtils.setProps("environment", environment, commonPropertyFilePath);            System.out.println("environment is " + environment);            System.out.println("suiteFileName is " + suiteFileName);            System.out.println("clientCountry is " + clientCountry);        } catch (NullPointerException e1) {            System.out.println("Environment is empty" + e1);        }        return environment;    }    protected boolean verifyPassword(String password) {        System.out.println("Password size is " + password.length());        if (password.length() >= 8) {            Pattern upperCaseletter = Pattern.compile("[A-Z]");            Pattern lowerCaseLetter = Pattern.compile("[a-z]");            Pattern digit = Pattern.compile("[0-9]");            Pattern specialCharacter = Pattern.compile("[~!@#$%^&*()-_+|\\;:\"\"'<>,.?/]");            Matcher hasUpperCaseLetter = upperCaseletter.matcher(password);            Matcher hasLowerCaseLetter = lowerCaseLetter.matcher(password);            Matcher hasDigit = digit.matcher(password);            Matcher hasSpecialCharacter = specialCharacter.matcher(password);            return hasUpperCaseLetter.find() && hasLowerCaseLetter.find() && hasDigit.find()                    && hasSpecialCharacter.find();        } else            return false;    }    public String base64Encoder(String Client_id, String Secret_key) {        String stringToEncode = Client_id + ":" + Secret_key;        // print String to be encoded        System.out.println("String to Encode :\n" + stringToEncode);        // Encode into Base64 format        String ENCODED_STRING = Base64.getEncoder().encodeToString(stringToEncode.getBytes());        // print encoded String        System.out.println("actual String:\n" + ENCODED_STRING);        return ENCODED_STRING;    }    protected static Faker fakerAPI() {        return new Faker();    }    protected List<String> getValuesForGivenKey(String jsonArrayStr, String key) {        JSONArray jsonArray = new JSONArray(jsonArrayStr);        System.out.println("Key::" + key);        return IntStream.range(0, jsonArray.length())                .mapToObj(index -> ((JSONObject) jsonArray.get(index)).optString(key))                .collect(Collectors.toList());    }    protected boolean validateResponseData(String responseData, String key, String value) {        for (String validate : getValuesForGivenKey(responseData, key)) {            if (validate.trim().equals(value)) {                System.out.println("validateData::" + validate.trim() + "::value::" + value);                return true;            }        }        return false;    }//    protected void validateResponseMessage(String actualResponse, String expectedResponse  log) {//        try {//            System.out.println("Actual Response " + actualResponse + "Expected Response " + expectedResponse);////            Assert.assertEquals(actualResponse, expectedResponse);//            SoftAssert softAssert = new SoftAssert();//            logger.log(MarkupHelper.createLabel("validateResponseMessage" );//            softAssert.assertEquals(actualResponse, expectedResponse,"validateResponseMessage");//        } catch (AssertionError e) {//            ExtentReportListener.testStepHandleAPI("FAIL", logger, new Exception());//            throw (e);//        }//    }//    protected void validateResponseMessage(String actualResponse, String expectedResponse, Scenario logger,String msg) {//        try {//            System.out.println("Actual Response " + actualResponse + "Expected Response " + expectedResponse);//            Assert.assertEquals(actualResponse, expectedResponse);//        } catch (AssertionError e) {//            ExtentReportListener.testStepHandleAPI("FAIL" , new Exception());//            throw (e);//        }//    }    public void validateResponseMessage(String actualResponse, String expectedResponse, Scenario logger, String msg) {        System.out.println("Actual Response " + actualResponse + "Expected Response " + expectedResponse);        if (actualResponse.equalsIgnoreCase(expectedResponse)) {            logger.log(msg);        } else {            SoftAssert softAssert = new SoftAssert();            logger.log("Expected status message not founded");            softAssert.assertFalse(true, msg);            logger.log("Actual Response--> " + actualResponse + " <----> " + "Expected Response--> " + expectedResponse);        }    }    public void validateStatusNumber(int actualResponse, int expectedResponse, Scenario logger, String msg) {        System.out.println("Actual Response " + actualResponse + " " + "Expected Response " + expectedResponse);        if (actualResponse == expectedResponse) {            org.testng.Assert.assertTrue(true);            logger.log(msg);        } else {            org.testng.Assert.assertTrue(false);//            SoftAssert softAssert = new SoftAssert();//            logger.log("Expected status number not founded");//            softAssert.assertFalse(true, msg);//            logger.log("Actual Response--> " + actualResponse + " -- " + "Expected Response--> " + expectedResponse);        }    }    public void validateAndVerifyStatusNumber(int actualResponse, int expectedResponse, Scenario logger, String msg) throws Throwable {//        int responseStatus = response.getStatusCode();        System.out.println("Response code is " + actualResponse);        System.out.println("Actual Response " + actualResponse + " " + "Expected Response " + expectedResponse);        if (actualResponse == expectedResponse) {            logger.log(msg);        } else {            SoftAssert softAssert = new SoftAssert();            logger.log("Expected status number not founded");            softAssert.assertFalse(true, msg);            logger.log("Actual Response--> " + actualResponse + " -- " + "Expected Response--> " + expectedResponse);        }    }    public void logFailWithoutStackTrace(String msg, Scenario logger) {//        extentTest.pass(MarkupHelper.createLabel(msg );        logger.log(msg);//        extentTest.error(throwable.fillInStackTrace());//        throwable.printStackTrace();    }    public void softFail(String msg, Scenario logger) {        SoftAssert softAssert = new SoftAssert();        logger.log(msg);        softAssert.assertFalse(true, msg);    }//    protected static String timeStampToEpochMillisSec(String timestamp) {//        if (timestamp == null)//            return null;//        try {//            SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ");//            Date dt = sdf.parse(timestamp);//            long epoch = dt.getTime();//            int milliSeconds = (int) (epoch / 1000);//            return Integer.toString(milliSeconds);//        } catch (ParseException e) {//            return null;//        }//    }    /*    Update the status of scenario in property file     */    public void updateTestScenarioStatus(String statusOfScenario) {        if (statusOfScenario.equalsIgnoreCase("passed")) {            int testsPassed = Integer.parseInt(PropUtils.getPropValue(commonProp, "testsPassed")) + 1;            PropUtils.setProps("testsPassed", String.valueOf(testsPassed), commonPropertyFilePath);        } else if (statusOfScenario.equalsIgnoreCase("failed")) {            int testsFailed = Integer.parseInt(PropUtils.getPropValue(commonProp, "testsFailed")) + 1;            PropUtils.setProps("testsFailed", String.valueOf(testsFailed), commonPropertyFilePath);        } else if (statusOfScenario.equalsIgnoreCase("skipped")) {            int testsSkipped = Integer.parseInt(PropUtils.getPropValue(commonProp, "testsSkipped")) + 1;            PropUtils.setProps("testsSkipped", String.valueOf(testsSkipped), commonPropertyFilePath);        }    }    /*    Method to refresh properties file     */    public void refreshPropertiesFile() {        inputProp = PropUtils.getProps(inputDataFile);    }    public String getOLSUerNameForResetAndChangePassword() {        olsUserName = PropUtils.getPropValue(inputProp, "userNameForChangeAndRestPasswordAPI");        return olsUserName;    }    public String getOLSPasswordForResetAndChangePassword() {        Properties inputProp = PropUtils.getProps(inputDataFile);        olsUserName = PropUtils.getPropValue(inputProp, "resetAndChangePasswordAPI");        return olsUserName;    }    public JSONObject jsonObjectBuilder(String key, String value) {        JSONObject objectBuilder = new JSONObject();        objectBuilder.put(key, value);        System.out.println("JSON object Builder -->" + objectBuilder.toString());        return objectBuilder;    }    public JSONArray jsonArrayBuilder(String key, String value) {        builder.put(key, value);        JSONArray array = new JSONArray();        array.put(builder);        System.out.println("JSON Array Builder -->" + array.toString());        return array;    }    public static long timeStampToEpochMillisSec(String timestamp) {        System.out.println("Inisde of time stamp method");        long epoch = 0;        String milliEpochSeconds = null;        //	SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");        //	Date dt;        try {            System.out.println("Inside of try block");            SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");            Date dt = sdf.parse(timestamp);            Calendar cal = Calendar.getInstance();            cal.setTime(dt);            cal.add(Calendar.HOUR, 12);            epoch = dt.getTime();            System.out.println("Epoch " + epoch);//				int milliSeconds = (int) (epoch / 1000);//				System.out.println("Milliseconds "+milliSeconds);//				milliEpochSeconds = Integer.toString(milliSeconds);//				System.out.println("MilliEpocheSeconds "+milliEpochSeconds);        } catch (ParseException e) {            // TODO Auto-generated catch block            e.printStackTrace();        }        return epoch;    }    public void assertTwoStringsForAPI(String actual, String expected, Scenario logger) {        logger.log("Actual String is " + actual);        logger.log("Expected String is " + expected);        Assert.assertEquals(actual, expected);        logger.log("Actual and expected values are same and validated both response and DB");    }    public int getRandomNumberInBetween(int lowerBound, int upperBound) {        Random r = new Random();        return (r.nextInt(upperBound) + lowerBound);    }}